# Хеш-таблица

## Часть 1. Написание хеш-таблицы

### Что такое хеш-таблица
Часто для хранения информации используют ```хеш-таблицу``` - структуру данных, представленную массивом, индексами которого являются хеши соответствующих им значений.
```Хеш``` - некоторое число, которое ставится в соответствие хранимому в таблице объекту исходя из хеш-функции.

Часто хеш-функция не является биективной и тогда возникают коллизии - равенства хешей у различных объектов.
Поэтому в качестве элементов массива (```backet```-ов) я использую списки из своего [другого проекта](https://github.com/ogkisque/List). В них быстро выполняются операции вставки и удаления.

Таким образом, подобрав "хорошие" хеш-функцию и размер таблицы, мы можем быстро выполнять поиск элемента в ней.
Для этого нужно посчитать его хеш, взять остаток от деления на размер таблицы - это будет индекс нужного списка в массиве.
Далее проходимся по этому списку и ищем нужный элемент (в "хорошем" случае длина списка будет небольшая).

Для оценки эффективности хеш-таблицы (равномерности распределения) мы будем использовать 2 характеристики:

```load factor``` = среднее количество элементов в непустых списках

```дисперсия``` $D = \dfrac{\sum\limits_{i=1} ^{n} (x_i - \overline{x})}{n}$

*P.S. В общем случае в хеш-таблице хранятся пары ключ-значение и хешируются ключи. В нашем случае будут храниться только ключи, поскольку это не принципиальнои и не является объектом изучения.
В качестве объектов я буду использовать строки из трагедии Шекспира "Гамлет"*

### Сравнение эффективности различных хtш-функций

* **Хеш, всегда равный 0**

    ```C++
    size_t get_hash_zero (Elemt elem)
    {
        return 0;
    }
    ```
    Конечно, такая функция не будет эффективна, поскольку все строки попадут в 0 список. Это видно по диаграмме распределения:

    <p align = "center">
      <img src = "https://github.com/ogkisque/Hash-Table/blob/master/hashtable/data/diag1.png" width = 60% height = 60%>
    </p>
    
* **Хеш, равный ASCII коду 1 символа**
